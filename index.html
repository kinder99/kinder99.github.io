<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>CAVE simulator</title>
<link type="text/css" rel="stylesheet" href="main.css">
</head>
<body>
<div id="info">
	CAVE Simulator. The head and teapot are draggable. <br />
	"L" See from Left Eye | "R" See from Right Eye | "S" toggle show scene  <br />
    While dragging an object, use the mousewheel to scale it. <br />
    Press "I" to increase IPD, "O" to decrease it.
</div>

<!-- Check: https://threejs.org/docs/index.html#manual/en/introduction/Installation 
for alternative installations -->

<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.139.2/build/three.module.js"
  }
}
</script>

<script src="https://unpkg.com/three@0.139.2/build/three.min.js"></script>
<script src="https://unpkg.com/three@0.139.2/examples/js/controls/OrbitControls.js"></script>
<script src="https://unpkg.com/three@0.139.2/examples/js/controls/DragControls.js"></script>
<script src="https://unpkg.com/three@0.139.2/examples/js/geometries/TeapotGeometry.js"></script>
<script src="https://unpkg.com/three@0.139.2/examples/js/controls/TransformControls.js"></script>


<script type="module">
import {XRButton} from 'https://unpkg.com/three@0.181.1/examples/jsm/webxr/XRButton.js';
import {XRControllerModelFactory} from 'https://unpkg.com/three@0.181.1/examples/jsm/webxr/XRControllerModelFactory.js';

class DisplaySurface 
{
    constructor(name, origin, u_vector, v_vector)
    {
        this.name = name;
        this.origin = origin;
        this.u = u_vector;
        this.v = v_vector;
    }

	viewMatrix(eye)
	{
        // compute target and up vector
        var u_norm = this.u.clone().normalize();
        var v_norm = this.v.clone().normalize();
        //var target = u_norm.cross(v_norm);
        //should be forward vector
		var normal = new THREE.Vector3().crossVectors(u_norm,v_norm);
        var target = new THREE.Vector3().subVectors(eye,normal);

        //compute up vector
        //var t_norm = target.normalize();
        var upVector = new THREE.Vector3(0,1,0);
        //var right = new THREE.Vector3().crossVectors(t_norm,temp);
		//var upVector = new THREE.Vector3().crossVectors(right,t_norm);

		var mat = new THREE.Matrix4();
		mat = mat.lookAt(eye, target, upVector); // this lookAt version creates only a rotation matrix
		var translate = new THREE.Matrix4().makeTranslation(-eye.x, -eye.y, -eye.z);
		mat = mat.multiplyMatrices(mat, translate);
		return mat;
	}
	
    projectionMatrix(eye, znear, zfar)
    {
        // compute the four values below
        // rigth vector is the dot product of normalized u and vector from cone
        var u_normalized = this.u.clone().normalize();
        var v_normalized = this.v.clone().normalize();

        // vector from the eye to the origin
        var eyeToOriginL = this.origin.clone();
        // add u and v to get right and top 
        var eyeToOriginR = this.origin.clone().add(this.u);
        var eyeToOriginTop = this.origin.clone().add(this.v);

        //console.log(eyeToOriginR);
        eyeToOriginL.sub(eye);
        eyeToOriginR.sub(eye);
        eyeToOriginTop.sub(eye)

        // vector from the eye to the display surface
        var eyeToSurface = this.v.clone().cross(this.u).normalize();

		// compute distances using dot products
        var leftP = eyeToOriginL.dot(u_normalized);
        var rightP = eyeToOriginR.dot(u_normalized);
        var bottomP = eyeToOriginL.dot(v_normalized);
        var topP = eyeToOriginTop.dot(v_normalized);
        var nearP = eyeToOriginL.dot(eyeToSurface);

        // use similar triangles
        var left = leftP * znear / nearP;
        var right = rightP * znear / nearP;
        var bottom = bottomP * znear / nearP;
        var top = topP * znear / nearP;

        var projMat = new THREE.Matrix4().makePerspective(left, right, top, bottom, znear, zfar)

        return projMat;
    }
}

var renderer, scene, camera;
var displaySurfaces, displaySurfaceScene, displaySurfaceTargets;
var eyeCenter, eyeScene;
var orbitControl, controls;
var showScene = true;
var current;
let container;

function setup()
{
    container = document.createElement( 'div' );
    document.body.appendChild( container );

    renderer = new THREE.WebGLRenderer({antialias: true});
    renderer.autoClear = false; //disable auto clearing because we want to draw the scene once for each eye
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setAnimationLoop(animate);
    container.appendChild(renderer.domElement);

    createDisplaySurfaces();	// Display surfaces
    createDisplaySurfaceTargets(); // Textures for the display surfaces
    createDisplaySurfaceScene();	// 3D objects for the display surfaces
    createEyeScene(6.8);	// spheres representing head + eyes
    createScene();		// some objects to test (teapot...)
    createCamera();		// a third-person camera
    enableOrbitCamera(camera, renderer);  // basic camera control
    addDragControlToObjects();	// allow some objects to be dragged
    animate();
}

function scaleFunc()
{
    console.log("i am here");
    current.scale.x += event.deltaY/500;
    current.scale.y += event.deltaY/500;
    current.scale.z += event.deltaY/500;
}

function addDragControlToObjects()
{
    var objects = [];
    objects.push(scene.getObjectByName("Teapot"));
    objects.push(scene.getObjectByName("Torus"));
    objects.push(eyeScene.getObjectByName("Head"));
    
	//console.log(objects);
	
    controls = new THREE.DragControls( objects, camera, renderer.domElement );
    controls.addEventListener( 'hoveron', function ( event ) 
		{
            orbitControl.enabled = false;
        } );
    controls.addEventListener( 'hoveroff', function ( event ) 
	{
            orbitControl.enabled = true;
    } );
	controls.addEventListener( 'dragstart', function ( event ) 
		{
            event.object.material.emissive.set( 0xaaaaaa );
            current = event.object;
            window.addEventListener('wheel', scaleFunc, false);
        } );
    controls.addEventListener( 'dragend', function ( event ) 
		{
            event.object.material.emissive.set( 0x000000 );
            window.removeEventListener('wheel', scaleFunc, false);
    } );
}

function createEyeScene(IPD)
{
    var IPD = 6.8;
    eyeCenter = new THREE.Vector3(50, 20, 50);
    // eye positions relative to the head
    var eyeL = new THREE.Vector3( - IPD/2, 10, -6);
    var eyeR = new THREE.Vector3( + IPD/2, 10, -6);
    
    eyeScene = new THREE.Scene();

    // add sphere representing head
    var geometry = new THREE.SphereGeometry( 10, 32, 22 );
    var material = new THREE.MeshPhongMaterial( { color: 0xaaaaaa } );
    var head = new THREE.Mesh( geometry, material );
    head.name = "Head";
    head.position.set(eyeCenter.x, eyeCenter.y, eyeCenter.z);
    eyeScene.add(head);

    // add spheres representing L/R eyes
    var geometry = new THREE.SphereGeometry( 3, 32, 22 );
    var material = new THREE.MeshPhongMaterial( { color: 0xff0000 } );
    var sphere = new THREE.Mesh( geometry, material );
    sphere.name = "EyeL";
    sphere.position.set(eyeL.x, eyeL.y, eyeL.z);
    head.add(sphere);
	
    var geometry = new THREE.SphereGeometry( 3, 32, 22 );
    var material = new THREE.MeshPhongMaterial( { color: 0x0000ff } );
    var sphere = new THREE.Mesh( geometry, material );
    sphere.name = "EyeR";
    sphere.position.set(eyeR.x, eyeR.y, eyeR.z);
	//sphere.position.set(0,0,50);
    head.add(sphere);
    
    createLights(eyeScene);
}

function createRenderer()
{
    renderer = new THREE.WebGLRenderer({preserveDrawingBuffer: true});
    renderer.autoClear = false; //disable auto clearing because we want to draw the scene once for each eye
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    //renderer.xr.enabled = true;
    //renderer.xr.setReferenceSpaceType('local');
    renderer.setAnimationLoop(animate);
    document.body.appendChild(renderer.domElement);
    //document.body.appendChild(XRButton.createButton(renderer));

    //setup();
}

function enableOrbitCamera(cam, renderer)
{
    orbitControl = new THREE.OrbitControls(cam, renderer.domElement );
    orbitControl.minDistance = 120;
    orbitControl.maxDistance = 50000;
}

function createLights(scn)
{
    var ambientLight = new THREE.AmbientLight(0x888888, 0.4);
    scn.add(ambientLight);
    var pointLight = new THREE.PointLight(0xffffff, 0.8);
	pointLight.position.z += 200;
    scn.add(pointLight);
}

function createScene()
{
    scene = new THREE.Scene();

    var geometry = new THREE.TeapotGeometry( 40, 15);
    var material = new THREE.MeshPhongMaterial( { color: 0xffffff } );
    var teapot = new THREE.Mesh(geometry, material);
    teapot.name = "Teapot";
    teapot.position.z-=70;
    scene.add( teapot );

    var geometry2 = new THREE.TorusGeometry( 10, 3, 15, 100);
    var material2 = new THREE.MeshPhongMaterial( { color: 0xffffff } );
    var torus = new THREE.Mesh(geometry2, material2);
    torus.name = "Torus";
    torus.position.z-=-75;
    scene.add( torus );
                
    createLights(scene);
}

// create a scene with 3D objects representing the display surfaces
function createDisplaySurfaceScene()
{
    displaySurfaceScene = new THREE.Scene();

    // add display surfaces
    for (var [index, displaySurface] of displaySurfaces.entries())
    {
        var origin = displaySurface.origin;
        var u = displaySurface.u;
        var v = displaySurface.v;
  
        var geometry = new THREE.BoxGeometry(u.length(), v.length(), 0.01);
        var material = new THREE.MeshPhongMaterial( {map: displaySurfaceTargets[index].texture} );
        var cube = new THREE.Mesh( geometry, material );
        cube.name = displaySurface.name;
        if (displaySurface.name == "Left")
            cube.rotation.y = Math.PI / 2;
       
		if (displaySurface.name == "Right")
            cube.rotation.y = - Math.PI / 2;
			
		if (displaySurface.name == "Floor")
		{
            cube.rotation.x =  Math.PI / 2;
            //cube.rotation.y = Math.PI / 2;
			cube.rotation.z = Math.PI;
		}
       
	    var uHalf = u.clone().multiplyScalar(0.5);
		var vHalf = v.clone().multiplyScalar(0.5);
		var center = new THREE.Vector3().addVectors(origin, uHalf);
		center.add(vHalf);
		cube.position.set(center.x, center.y, center.z);
		
        displaySurfaceScene.add(cube);
    }
    
    createLights(displaySurfaceScene);
}

function createDisplaySurfaceTargets()
{
    const SIZE = 1024;  // texture resolution
    displaySurfaceTargets = [];
    
    for (var v of displaySurfaces)
        displaySurfaceTargets.push(new THREE.WebGLRenderTarget(SIZE, SIZE));
}

function createCamera()
{
    camera = new THREE.PerspectiveCamera( 75, window.innerWidth/window.innerHeight, 0.1, 10000 );
    camera.position.set( 100, 100, 300 );
    camera.lookAt( 0, 0, 0 );
}

function createDisplaySurfaces()
{
    displaySurfaces = [];
    // FRONT SCREEN
    var frontScreen = new DisplaySurface("Front", 
        new THREE.Vector3(-150.0, -150.0, -150.0), 
        new THREE.Vector3(300.0, 0.0,   0.0), 
        new THREE.Vector3(0.0, 300.0,   0.0));
    displaySurfaces.push(frontScreen);

    // LEFT SCREEN
    var leftScreen = new DisplaySurface("Left",
        new THREE.Vector3(-150.0, -150.0, 150.0), 
        new THREE.Vector3(0.0, 0.0,  -300.0), 
        new THREE.Vector3(0.0, 300.0,   0.0));
    displaySurfaces.push(leftScreen);

    //RIGHT SCREEN
    var rightScreen = new DisplaySurface("Right",
        new THREE.Vector3(150.0,-150.0,-150.0),
        new THREE.Vector3(0.0,0.0,300.0),
        new THREE.Vector3(0.0,300.0,0.0));
    displaySurfaces.push(rightScreen);

    //BOTTOM SCREEN
    var bottomScreen = new DisplaySurface("Floor",
        new THREE.Vector3(-150.0,-150.0,150.0),
        new THREE.Vector3(300.0,0.0,0.0),
        new THREE.Vector3(0.0,0.0,-300.0));
    displaySurfaces.push(bottomScreen);
	
}

function getLeftEyePosition()
{
    var eye = eyeScene.getObjectByName("EyeL");
    return eye.getWorldPosition(new THREE.Vector3());
}

function getRightEyePosition()
{
    var eye = eyeScene.getObjectByName("EyeR");
    return eye.getWorldPosition(new THREE.Vector3());
}

function cameraFromViewProj(view, proj)
{
	var cam = camera.clone();
    var inv = new THREE.Matrix4();
	inv.copy(view).invert();
	cam.position.set(inv.elements[12], inv.elements[13], inv.elements[14]);
	cam.setRotationFromMatrix(view);
	cam.projectionMatrix = proj.clone();
	return cam;
}

function handleVRControllerButton(buttonId, source) {
    if(source.handedness == "right") {
        switch(buttonId) {
            case 4: useVReyes = !useVReyes; break;
            case 5: showScene = !showScene; break;
        }
    }
}

// refresh function
function animate()
{
    var gl = renderer.getContext();
    requestAnimationFrame(animate);

    var prev = renderer.xr.enabled;

    renderer.xr.enabled = false;
	renderer.setClearColor(0x808080);
    renderer.clear();
    if (showScene)
        renderer.render(scene, camera);
    
    // 2. render scene objects onto a texture, for each target
    for (let [index, displaySurface] of displaySurfaces.entries())
    {
        renderer.setRenderTarget(displaySurfaceTargets[index]);
        renderer.setClearColor(0x404040);
        renderer.clear();

		// left eye on RED channel
        gl.colorMask(1, 0, 0, 0);
		var eye = getLeftEyePosition();
		var view = displaySurface.viewMatrix(eye);
		var proj = displaySurface.projectionMatrix(eye, 1, 10000);
        var leftCamera = cameraFromViewProj(view, proj);
        renderer.render(scene, leftCamera);
    
		// right eye on GREEN, BLUE channels
		gl.colorMask(0, 1, 1, 0);
		var eye = getRightEyePosition();
		var view = displaySurface.viewMatrix(eye);
		var proj = displaySurface.projectionMatrix(eye, 1, 10000);
        var rightCamera = cameraFromViewProj(view, proj);
        renderer.clearDepth();
        renderer.render(scene, rightCamera);
		
        gl.colorMask(1, 1, 1, 0);
    }
    renderer.xr.enabled = prev;
    // restore state
    renderer.setRenderTarget(null);
    renderer.setClearColor(0x000000);
  
    // 3. render display surfaces as (textured) quads
    renderer.render(displaySurfaceScene, camera);
	
	// 4. render eyes
    renderer.render(eyeScene, camera);
	
};

function increaseIPD(ipd)
{
    var head = eyeScene.getObjectByName("Head");
    var eyel = eyeScene.getObjectByName("EyeL");
    var eyer = eyeScene.getObjectByName("EyeR");

    var headPos = head.position;
    //eyel.position = new THREE.Vector3(headPos.x - ipd/2, headPos.y + 10, headPos.z-6);
    //eyer.position = new THREE.Vector3(headPos.x + ipd/2, headPos.y + 10, headPos.z-6);
    eyel.position.x -= ipd/2;
    eyer.position.x += ipd/2;
}

function decreaseIPD(ipd)
{
    var head = eyeScene.getObjectByName("Head");
    var eyel = eyeScene.getObjectByName("EyeL");
    var eyer = eyeScene.getObjectByName("EyeR");

    var headPos = head.position;
    //eyel.position = new THREE.Vector3(headPos.x - ipd/2, headPos.y + 10, headPos.z-6);
    //eyer.position = new THREE.Vector3(headPos.x + ipd/2, headPos.y + 10, headPos.z-6);
    eyel.position.x += ipd/2;
    eyer.position.x -= ipd/2;
}

window.addEventListener( 'keydown', function ( event ) 
{
        switch ( event.code ) {
            case 'KeyL':
                var eye = getLeftEyePosition();
                camera.position.set(eye.x, eye.y, eye.z);
                break;
                
            case 'KeyR':
                var eye = getRightEyePosition();
                camera.position.set(eye.x, eye.y, eye.z);
                break;
                
            case 'KeyS':
                showScene = !showScene;
                break;
				
			case 'KeyT':
				var viewF = displaySurfaces[0].viewMatrix(new THREE.Vector3(50,20,100));
				var viewL = displaySurfaces[1].viewMatrix(new THREE.Vector3(50,20,100));
				var viewR = displaySurfaces[2].viewMatrix(new THREE.Vector3(50,20,100));
				//var viewB = displaySurfaces[3].viewMatrix(new THREE.Vector3(50,20,100));
				console.log("View matrices:");
				console.log(viewF);
				console.log(viewL);
				console.log(viewR);
				//console.log(viewB);

                
				var projF = displaySurfaces[0].projectionMatrix(new THREE.Vector3(0,0,0),1,1000);
				var viewL = displaySurfaces[1].viewMatrix(new THREE.Vector3(50,20,100));
				var viewR = displaySurfaces[2].viewMatrix(new THREE.Vector3(50,20,100));
				//var viewB = displaySurfaces[3].viewMatrix(new THREE.Vector3(50,20,100));
				console.log("Projection matrices:");
				console.log(projF);
				console.log(viewL);
				console.log(viewR);
				break;
            case 'KeyI':
                increaseIPD(8);
                break;
            case 'KeyO':
                decreaseIPD(8);
                break;
        }
    }
);

setup();
//createRenderer();  			// create WebGL renderer
		</script>
    </body>
</html>
